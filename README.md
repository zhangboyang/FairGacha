# 一种公平无猫腻的游戏抽卡系统

简单的密码学（笑）

## 背景

在抽卡游戏中，玩家用来抽卡的资源往往来之不易，因此在抽卡时，都希望自己的运气能好一些。但随着抽卡次数的增加，不好的运气总会到来。如果多次遇到运气不好的情况（如“保底歪了”），玩家会自然而然地产生“这抽卡系统会不会有猫腻（暗箱操作）？”的想法。但因为抽卡本来就依赖于概率，这种想法自然很难证实也很难证伪。一般只能依靠“如果有猫腻，游戏厂商会被告到破产”这种想法来侧面证明，对玩家而言实在没太大说服力。

以普遍理性而论，玩家与游戏厂商都希望抽卡系统是“可以证明无猫腻”的：

1. 对玩家而言，如果遇到了不好的运气，一个“可以证明无猫腻”的抽卡系统才能让玩家有继续玩下去的动力。

2. 对游戏厂商而言，一个“可以证明无猫腻”的抽卡系统，可以最大限度地洗刷掉有猫腻的嫌疑，让玩家持续安心地在游戏中游玩，从而获得更多的收益。

## 实现

抽卡流程如下：

1. 游戏厂商公布卡池的实现代码。该代码的随机性仅依赖于给定的随机种子。

2. 服务器端为卡池产生一个随机种子A（对玩家保密，但必须经过玩家同意才可更换）。使用密码学哈希函数（如SHA256），计算随机种子A的指纹，记为B，显示在玩家的抽卡界面上。

3. 玩家先记录下抽卡界面上的B，再提交一个自己生成的随机种子C。这一环节可以包装成“提交抽卡咒语”等，提升游戏体验。

4. 服务器根据A xor C计算出抽卡代码所使用的随机种子R（对玩家保密）。

5. （该步骤可以重复多次）玩家提交抽卡请求，服务器根据卡池状态和随机种子R，计算出抽卡结果并更新卡池状态。

6. （重点来了）当玩家遇到了不好的运气，觉得“可能有猫腻”时，可以请求服务器出示随机种子A。玩家得到A后，核对它的指纹B，并根据A、C计算出R，进而计算出所有抽卡结果。 **核对一致后，玩家就只能懊悔自己的随机种子C选得不够好。** 当服务器端出示了A后，A随即作废，下一次抽卡时需要重新走一遍随机种子的生成流程。

## 细节讨论

* 为何抽卡结果对于双方来说是公平的？因为根据密码学原理，A或C只要至少有一方是完全随机生成的，那么R就是随机的。

* 如何防止服务器端偷换A？因为A的指纹B在玩家决定C之前就已经发送给玩家了，如果服务器端偷换种子，则玩家核对B时就可发现。

* 如何防止服务器端明换A？因为服务器端可以预知所有抽卡结果，游戏厂商可能有动力阻止一个对游戏厂商不利的R继续生效。为了防止这种情况发生，A必须经过玩家确认同意之后才可更换。

* 如何防止玩家预知抽卡结果？因为A和R在未出示前是对玩家保密的。虽然A的指纹B提供给了玩家，但根据密码学原理，无法通过B反向计算得到A，也就无法得到R去计算抽卡结果。

## 最佳实践

* 对于抽卡代码，应使用业界公认的伪随机数生成器（如AES-CTR）。一方面可消除猫腻嫌疑，另一方面也可防止玩家利用随机数生成器的缺陷获取更优的抽卡结果。

* 对于服务器端，为了游戏厂商自身的利益，应该使用密码学随机数生成器来生成随机种子A，因为如果A不够随机，则玩家有可能利用缺陷获取更优的抽卡结果。

* 对于客户端，如何将“产生随机种子C”包装得既公平又不影响游戏体验很重要。一种不影响游戏体验的可能的方式是调用系统提供的密码学随机数生成器（如/dev/urandom）。另一种可能增加游戏体验的可能的方式是，请玩家随机绘制一张图，并对该图的内容进行密码学哈希来得到C。这种方法需要注意图的分辨率不宜过大或过小：如果分辨率过小，随机性可能不足；如果分辨率过大，则有通过微小扰动隐藏猫腻的空间。

* 对于玩家，需要认真按照要求进行每一步操作，该记录的记录，该核对的核对，这样游戏厂商才没有猫腻的空间。一种简单的记录办法是对抽卡过程（尤其是随机种子生成的过程）进行录屏。

## 缺陷

* 如果玩家不按照要求进行操作，就无法防止游戏厂商针对性作弊。
  
* 如果游戏厂商公布的卡池代码中有BUG，则容易引起风波。

* 不能防止玩家和游戏厂商一起作弊。例如：为了节目效果，游戏主播和游戏厂商串通。

* 如果玩家不更换随机种子，游戏厂商完全可以预测玩家的所有抽卡结果。这一点可以通过每一次抽卡都重新生成随机种子进行规避。这一点也可以通过将随机种子的适用范围从卡池扩展到整个游戏来进行规避（因为游戏互动对游戏厂商几乎不可预知），但这也对玩家游戏过程的记录提高了要求。

* 不能防止玩家通过P图等手段进行恶意栽赃。

## 改进空间

* 利用数字签名等更高级的密码学技术防止栽赃或抵赖。

* 使用密码学哈希函数等其它算法替换A xor C，可防止从R、C逆算出A（不过好像没什么用）。

* 增加salt和哈希迭代次数，抵御暴力破解或者（可能的）量子破解算法。
